'use client'

import React from 'react'
import { Camera, ArrowLeft, AlertTriangle, RotateCcw, Upload } from 'lucide-react'
import { Button } from '@/components/ui/button'

// Types for different capture scenarios
export type CaptureType = 'document' | 'vin' | 'license_plate' | 'odometer' | 'receipt' | 'dashboard_snapshot'

export type FrameGuideType = 
  | 'document-frame'      // Large rectangular for documents
  | 'vin-plate'          // Narrow rectangle for VIN plates  
  | 'license-plate'      // License plate dimensions
  | 'odometer-display'   // Circular/digital display
  | 'receipt-frame'      // Receipt dimensions
  | 'dashboard-cluster'   // Full dashboard view

export interface CaptureResult<T = any> {
  success: boolean
  data?: T
  error?: string
  confidence?: number
  processed_at: string
}

export interface UnifiedCameraCaptureProps {
  // Core configuration
  captureType: CaptureType
  frameGuide: FrameGuideType
  instructions: string
  
  // Callbacks
  onCapture: (result: CaptureResult) => void
  onCancel?: () => void
  
  // Processing
  processingAPI: string
  
  // UI customization
  title?: string
  allowFileUpload?: boolean
  
  // Advanced options
  cameraConstraints?: MediaStreamConstraints['video']
  maxRetries?: number
}

export function UnifiedCameraCapture({
  captureType,
  frameGuide,
  instructions,
  onCapture,
  onCancel,
  processingAPI,
  title,
  allowFileUpload = true,
  cameraConstraints,
  maxRetries = 3
}: UnifiedCameraCaptureProps) {
  
  // Flow state
  const [currentState, setCurrentState] = React.useState<'choice' | 'camera' | 'processing'>('choice')
  const [error, setError] = React.useState<string | null>(null)
  const [isProcessing, setIsProcessing] = React.useState(false)
  const [retryCount, setRetryCount] = React.useState(0)
  
  // Camera management (extracted from UnifiedPhotoModal)
  const videoRef = React.useRef<HTMLVideoElement>(null)
  const canvasRef = React.useRef<HTMLCanvasElement>(null)
  const streamRef = React.useRef<MediaStream | null>(null)
  const fileInputRef = React.useRef<HTMLInputElement>(null)
  const isStartingCamera = React.useRef<boolean>(false)
  const userRequestedCamera = React.useRef<boolean>(false)
  const allStreams = React.useRef<MediaStream[]>([])
  
  // Device detection
  const [isMobile, setIsMobile] = React.useState(false)
  
  React.useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
    }
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  // Camera lifecycle management
  React.useEffect(() => {
    return () => {
      // Cleanup on unmount
      globalCameraCleanup()
    }
  }, [])

  React.useEffect(() => {
    if (currentState !== 'camera') {
      stopCamera()
    }
  }, [currentState])

  // Camera management functions (proven logic from UnifiedPhotoModal)
  const startCamera = async () => {
    if (!userRequestedCamera.current) {
      console.log('üö´ Camera start blocked - no user interaction detected')
      return
    }
    
    if (isStartingCamera.current || streamRef.current) {
      console.log('üö´ Camera already starting or active, skipping...')
      return
    }
    
    console.log(`üìπ Starting camera for ${captureType}...`)
    isStartingCamera.current = true
    
    try {
      stopCamera()
      
      const constraints = cameraConstraints || {
        facingMode: 'environment',
        width: { ideal: 1280 },
        height: { ideal: 720 }
      }
      
      const stream = await navigator.mediaDevices.getUserMedia({ video: constraints })
      
      console.log('‚úÖ Camera stream obtained')
      streamRef.current = stream
      allStreams.current.push(stream)
      console.log('üìä Total streams tracked:', allStreams.current.length)
      
      if (videoRef.current) {
        videoRef.current.srcObject = stream
        console.log('üì∫ Video element connected to stream')
      }
    } catch (error) {
      console.error('‚ùå Camera error:', error)
      setError('Camera access denied. Please allow camera permissions.')
    } finally {
      isStartingCamera.current = false
    }
  }

  const globalCameraCleanup = async () => {
    if (allStreams.current.length === 0 && !streamRef.current) {
      console.log('üö´ Skipping cleanup - no streams to clean')
      return
    }
    
    console.log(`üî• GLOBAL CAMERA CLEANUP for ${captureType} - Stopping ALL streams...`)
    
    isStartingCamera.current = false
    userRequestedCamera.current = false
    
    // Stop ALL tracked streams
    console.log('üìä Stopping all tracked streams:', allStreams.current.length)
    allStreams.current.forEach((stream, index) => {
      console.log(`‚èπÔ∏è Stopping tracked stream ${index + 1}:`)
      stream.getTracks().forEach(track => {
        console.log(`  - ${track.kind} track:`, track.readyState)
        track.stop()
      })
    })
    allStreams.current = []
    
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => {
        console.log('‚èπÔ∏è Stopping main stream:', track.kind)
        track.stop()
      })
      streamRef.current = null
    }
    
    if (videoRef.current) {
      const video = videoRef.current
      const videoStream = video.srcObject as MediaStream
      if (videoStream && videoStream.getTracks) {
        videoStream.getTracks().forEach(track => {
          console.log('‚èπÔ∏è Stopping video element track:', track.kind)
          track.stop()
        })
      }
      
      video.pause()
      video.srcObject = null
      video.src = ''
      video.load()
      video.onloadedmetadata = null
      video.oncanplay = null
    }
    
    console.log('‚úÖ Global camera cleanup complete')
  }

  const stopCamera = () => {
    console.log(`üõë Stopping camera for ${captureType}...`)
    
    if (streamRef.current) {
      console.log('üìπ Found active stream, stopping all tracks...')
      streamRef.current.getTracks().forEach(track => {
        console.log('‚èπÔ∏è Stopping track:', track.kind, track.readyState)
        track.stop()
      })
      streamRef.current = null
    }
    
    if (videoRef.current) {
      console.log('üì∫ Clearing video element...')
      const video = videoRef.current
      const videoStream = video.srcObject as MediaStream
      if (videoStream && videoStream.getTracks) {
        videoStream.getTracks().forEach(track => {
          console.log('‚èπÔ∏è Stopping video element track:', track.kind)
          track.stop()
        })
      }
      
      video.pause()
      video.srcObject = null
      video.src = ''
      video.load()
      video.onloadedmetadata = null
      video.oncanplay = null
    }
    
    isStartingCamera.current = false
    console.log('‚úÖ Camera stop complete')
  }

  const capturePhoto = async () => {
    console.log(`üì∏ Starting photo capture for ${captureType}...`)
    if (!videoRef.current || !canvasRef.current) return

    try {
      const video = videoRef.current
      const canvas = canvasRef.current
      const ctx = canvas.getContext('2d')
      
      if (!ctx) return

      console.log('üé¨ Capturing frame from video...')
      canvas.width = video.videoWidth
      canvas.height = video.videoHeight
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height)
      
      console.log('üì∏ Frame captured, stopping camera NOW...')
      stopCamera()
      setIsProcessing(true)
      setCurrentState('processing')
      
      canvas.toBlob(async (blob) => {
        if (!blob) return
        
        await processImage(blob)
      }, 'image/jpeg', 0.9)
      
    } catch (error) {
      console.error('‚ùå Capture error:', error)
      setError('Failed to capture photo. Please try again.')
      setIsProcessing(false)
    }
  }

  const processImage = async (imageBlob: Blob) => {
    try {
      const formData = new FormData()
      formData.append('image', imageBlob, `${captureType}.jpg`)
      formData.append('document_type', captureType)
      formData.append('mode', 'auto')
      
      console.log(`üîÑ Processing ${captureType} image...`)
      
      const response = await fetch(processingAPI, {
        method: 'POST',
        body: formData
      })

      if (!response.ok) {
        throw new Error(`Processing failed: ${response.status}`)
      }

      const result = await response.json()
      console.log(`‚úÖ ${captureType} processing complete:`, result)
      
      const processedResult: CaptureResult = {
        success: result.success || true,
        data: result.success ? result.data : result,
        processed_at: result.processed_at || new Date().toISOString()
      }
      
      onCapture(processedResult)
      
    } catch (error) {
      console.error(`‚ùå ${captureType} processing error:`, error)
      
      if (retryCount < maxRetries) {
        setRetryCount(prev => prev + 1)
        setError(`Processing failed. Retrying... (${retryCount + 1}/${maxRetries})`)
        setTimeout(() => processImage(imageBlob), 1000)
      } else {
        const errorResult: CaptureResult = {
          success: false,
          error: error instanceof Error ? error.message : 'Processing failed',
          processed_at: new Date().toISOString()
        }
        onCapture(errorResult)
      }
    } finally {
      setIsProcessing(false)
    }
  }

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    console.log(`üìÅ File upload for ${captureType}:`, file.name)
    setIsProcessing(true)
    setCurrentState('processing')
    
    await processImage(file)
  }

  const handleStartCamera = () => {
    console.log(`üëÜ User clicked "Take Photo" for ${captureType} - enabling camera...`)
    userRequestedCamera.current = true
    setCurrentState('camera')
  }

  const handleBack = () => {
    console.log(`‚¨ÖÔ∏è Back button pressed from ${currentState}`)
    if (currentState === 'camera') {
      userRequestedCamera.current = false
      stopCamera()
    }
    setCurrentState('choice')
    setError(null)
  }

  const handleCancel = () => {
    globalCameraCleanup()
    onCancel?.()
  }

  // Render different states
  if (currentState === 'processing') {
    return (
      <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center">
        <div className="bg-white rounded-lg p-6 text-center max-w-sm mx-4">
          <div className="animate-spin w-8 h-8 border-2 border-blue-600 border-t-transparent rounded-full mx-auto mb-4"></div>
          <div className="text-lg font-medium text-gray-900 mb-2">
            Processing {captureType.replace('_', ' ')}...
          </div>
          <div className="text-sm text-gray-600">
            Extracting information using AI
          </div>
        </div>
      </div>
    )
  }

  if (currentState === 'camera') {
    return <FullScreenCameraView />
  }

  // Choice view
  return (
    <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center">
      <div className="bg-white rounded-lg max-w-md mx-4 w-full">
        <div className="p-6">
          <div className="text-center mb-8">
            <Camera className="w-16 h-16 mx-auto mb-4 text-blue-600" />
            <div className="text-xl font-semibold text-gray-900 mb-2">
              {title || `Capture ${captureType.replace('_', ' ')}`}
            </div>
            <div className="text-sm text-gray-600">
              {isMobile ? 'Choose how to capture' : 'Take a photo or choose from files'}
            </div>
          </div>

          <div className="space-y-4">
            <Button
              onClick={handleStartCamera}
              className="w-full h-14 text-lg"
              size="lg"
            >
              <Camera className="w-5 h-5 mr-3" />
              Take Photo
            </Button>

            {allowFileUpload && (
              <Button
                onClick={() => {
                  console.log('üì§ Upload button clicked')
                  const input = document.createElement('input')
                  input.type = 'file'
                  input.accept = 'image/*'
                  input.onchange = (e) => {
                    const file = (e.target as HTMLInputElement).files?.[0]
                    if (file) {
                      console.log('üì§ File selected:', file.name)
                      handleFileUpload({ target: { files: [file] } } as any)
                    }
                  }
                  input.click()
                }}
                variant="outline"
                className="w-full h-14 text-lg"
                size="lg"
              >
                <Upload className="w-5 h-5 mr-3" />
                Upload Photo
              </Button>
            )}

            <Button
              onClick={handleCancel}
              variant="ghost"
              className="w-full"
            >
              Cancel
            </Button>
          </div>

        </div>
    </div>
  )

  // Full screen camera component
  function FullScreenCameraView() {
    React.useEffect(() => {
      console.log(`üìπ FullScreenCameraView mounted for ${captureType}`)
    }, [captureType])
          playsInline
          muted
          className="w-full h-full object-cover"
        />
        
        {/* Hidden canvas for capture */}
        <canvas ref={canvasRef} className="hidden" />

        {/* Camera UI Overlay */}
        <div className="absolute inset-0 flex flex-col">
          {/* Top Bar */}
          <div className="flex items-center justify-between p-4 bg-gradient-to-b from-black/50 to-transparent">
            <button
              onClick={handleBack}
              className="p-2 rounded-full bg-black/30 text-white hover:bg-black/50 transition-colors"
            >
              <ArrowLeft className="w-6 h-6" />
            </button>
            <div className="text-white text-lg font-medium">
              {title || `Capture ${captureType.replace('_', ' ')}`}
            </div>
            <div className="w-10" />
          </div>

          {/* Center - Frame Guide */}
          <div className="flex-1 flex items-center justify-center p-4 sm:p-6 md:p-8">
            <FrameGuide type={frameGuide} instructions={instructions} />
          </div>

          {/* Bottom Bar - Capture Button */}
          <div className="p-8 bg-gradient-to-t from-black/50 to-transparent">
            <div className="flex items-center justify-center">
              <button
                onClick={capturePhoto}
                className="w-20 h-20 bg-white rounded-full flex items-center justify-center hover:bg-gray-100 transition-colors shadow-lg"
              >
                <div className="w-16 h-16 bg-white border-4 border-gray-300 rounded-full flex items-center justify-center">
                  <Camera className="w-8 h-8 text-gray-600" />
                </div>
              </button>
            </div>
          </div>
        </div>
      </div>
    )
  }
}

// Frame guide component with different variants
function FrameGuide({ type, instructions }: { type: FrameGuideType; instructions: string }) {
  const getFrameStyle = () => {
    switch (type) {
      case 'document-frame':
        return 'w-full max-w-sm sm:max-w-md md:max-w-lg lg:max-w-xl h-full max-h-80 sm:max-h-96 md:max-h-[28rem]'
      case 'vin-plate':
        return 'w-full max-w-xs sm:max-w-sm h-16 sm:h-20'
      case 'license-plate':
        return 'w-full max-w-sm h-24 sm:h-28'
      case 'odometer-display':
        return 'w-48 h-48 sm:w-56 sm:h-56 rounded-full'
      case 'receipt-frame':
        return 'w-full max-w-xs sm:max-w-sm h-full max-h-96'
      default:
        return 'w-full max-w-sm h-64'
    }
  }

  const getBorderStyle = () => {
    switch (type) {
      case 'odometer-display':
        return 'border-2 border-white border-dashed rounded-full'
      default:
        return 'border-2 border-white border-dashed rounded-2xl'
    }
  }

  return (
    <div className={`relative ${getFrameStyle()}`}>
      <div className={`${getBorderStyle()} w-full h-full min-h-[8rem] flex items-center justify-center`}>
        <div className="text-white text-sm sm:text-base font-medium bg-black/50 px-4 py-2 rounded-lg text-center">
          {instructions}
        </div>
      </div>

      {/* Corner guides for rectangular frames */}
      {!type.includes('odometer') && (
        <>
          <div className="absolute top-2 left-2 w-6 h-6 border-l-4 border-t-4 border-white rounded-tl-lg"></div>
          <div className="absolute top-2 right-2 w-6 h-6 border-r-4 border-t-4 border-white rounded-tr-lg"></div>
          <div className="absolute bottom-2 left-2 w-6 h-6 border-l-4 border-b-4 border-white rounded-bl-lg"></div>
          <div className="absolute bottom-2 right-2 w-6 h-6 border-r-4 border-b-4 border-white rounded-br-lg"></div>
        </>
      )}
    </div>
  )
}

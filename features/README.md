# üéØ features/ Directory

**Purpose:** Feature modules - the PRIMARY codebase where all feature-specific business logic lives.

---

## üéØ What Is a Feature?

A **feature** is a distinct area of functionality that:
- ‚úÖ Has clear user-facing functionality
- ‚úÖ Contains business logic and domain models
- ‚úÖ Can be developed and tested independently
- ‚úÖ Owns its UI, data, and business rules

**Features are the heart of the codebase!** ‚≠ê

---

## üìÅ Current Features

```
features/
‚îú‚îÄ‚îÄ assistant/       # AI assistant and chat
‚îú‚îÄ‚îÄ auth/            # Authentication and authorization
‚îú‚îÄ‚îÄ capture/         # Photo and document capture
‚îú‚îÄ‚îÄ chat/            # Conversational interface
‚îú‚îÄ‚îÄ events/          # Vehicle event management
‚îú‚îÄ‚îÄ insights/        # Analytics and insights
‚îú‚îÄ‚îÄ migrations/      # Data migrations
‚îú‚îÄ‚îÄ timeline/        # Event timeline display
‚îú‚îÄ‚îÄ vehicles/        # Vehicle management
‚îî‚îÄ‚îÄ vision/          # Computer vision and OCR
```

---

## üèóÔ∏è Standard Feature Structure

### **Recommended Layout:**

```
features/[feature-name]/
‚îÇ
‚îú‚îÄ‚îÄ domain/              # Business logic & types (PURE)
‚îÇ   ‚îú‚îÄ‚îÄ types.ts        # Domain types
‚îÇ   ‚îú‚îÄ‚îÄ schemas.ts      # Validation schemas
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts    # Feature constants
‚îÇ   ‚îî‚îÄ‚îÄ validation.ts   # Business rules
‚îÇ
‚îú‚îÄ‚îÄ data/                # Data access layer
‚îÇ   ‚îú‚îÄ‚îÄ api.ts          # API endpoints
‚îÇ   ‚îú‚îÄ‚îÄ queries.ts      # React Query queries
‚îÇ   ‚îú‚îÄ‚îÄ mutations.ts    # React Query mutations
‚îÇ   ‚îî‚îÄ‚îÄ cache.ts        # Caching logic
‚îÇ
‚îú‚îÄ‚îÄ hooks/               # React hooks
‚îÇ   ‚îú‚îÄ‚îÄ useFeature.ts   # Main feature hook
‚îÇ   ‚îî‚îÄ‚îÄ useFeatureData.ts
‚îÇ
‚îú‚îÄ‚îÄ ui/                  # UI components
‚îÇ   ‚îú‚îÄ‚îÄ FeatureView.tsx # Main view
‚îÇ   ‚îú‚îÄ‚îÄ FeatureForm.tsx # Form components
‚îÇ   ‚îî‚îÄ‚îÄ components/     # Sub-components
‚îÇ       ‚îú‚îÄ‚îÄ FeatureList.tsx
‚îÇ       ‚îî‚îÄ‚îÄ FeatureCard.tsx
‚îÇ
‚îú‚îÄ‚îÄ utils/               # Feature-specific utilities
‚îÇ   ‚îî‚îÄ‚îÄ helpers.ts
‚îÇ
‚îî‚îÄ‚îÄ README.md            # Feature documentation
```

### **Not all features need all folders!**
Only create what you need. Small features might just have:
```
features/simple-feature/
‚îú‚îÄ‚îÄ ui/              # UI components
‚îî‚îÄ‚îÄ hooks/           # React hooks
```

---

## üé® Folder Purposes

### **domain/** - Business Logic
```
Purpose: Pure business logic and domain models
Contains:
- Type definitions
- Business rules
- Validation logic
- Constants
- Domain calculations

Rules:
‚úÖ NO side effects
‚úÖ NO API calls
‚úÖ NO UI code
‚úÖ 100% testable
‚úÖ Pure functions only
```

### **data/** - Data Access
```
Purpose: All data fetching and mutations
Contains:
- API endpoint definitions
- React Query queries
- React Query mutations
- Cache management
- Data transformations

Rules:
‚úÖ Uses React Query
‚úÖ Error handling included
‚úÖ Loading states managed
‚úÖ Optimistic updates where appropriate
```

### **hooks/** - React Hooks
```
Purpose: Feature-specific React hooks
Contains:
- Custom hooks for this feature
- State management hooks
- Effect hooks

Rules:
‚úÖ Follow React hooks rules
‚úÖ Prefix with "use"
‚úÖ Only feature-specific hooks
‚úÖ Shared hooks go in /hooks at root
```

### **ui/** - User Interface
```
Purpose: UI components for this feature
Contains:
- Feature views/pages
- Feature forms
- Feature-specific components
- Sub-component folder

Rules:
‚úÖ Use design system components
‚úÖ Follow layout system
‚úÖ Container pattern for data
‚úÖ Presentational components
```

### **utils/** - Utilities
```
Purpose: Feature-specific helper functions
Contains:
- Formatters
- Parsers
- Helpers
- Calculations

Rules:
‚úÖ Only used within this feature
‚úÖ If used by 2+ features ‚Üí lib/utils/
‚úÖ Pure functions preferred
‚úÖ Fully tested
```

---

## üö¶ When to Create a New Feature

### **Create a Feature When:**

```
‚úÖ It has distinct user-facing functionality
‚úÖ It can be developed independently
‚úÖ It has its own domain models
‚úÖ It will contain 5+ files
‚úÖ It has clear boundaries
‚úÖ It owns specific business logic
```

### **Examples:**

```
‚úÖ features/auth/         - Authentication system
‚úÖ features/capture/      - Photo capture workflow
‚úÖ features/timeline/     - Event timeline display
‚úÖ features/chat/         - Conversational interface
```

### **DON'T Create a Feature For:**

```
‚ùå Shared UI components    ‚Üí components/design-system/
‚ùå General utilities       ‚Üí lib/utils/
‚ùå Infrastructure code     ‚Üí lib/infrastructure/
‚ùå Single component        ‚Üí Put in existing feature
‚ùå Routes only             ‚Üí app/ directory
```

---

## üìã Feature Development Workflow

### **1. Plan the Feature**

```markdown
Answer these questions:
- What problem does it solve?
- What are the domain models?
- What data does it need?
- What UI will it have?
- Does it depend on other features?
```

### **2. Create Feature Structure**

```bash
# Create feature directory
mkdir -p features/my-feature/{domain,data,hooks,ui,utils}

# Create initial files
touch features/my-feature/domain/types.ts
touch features/my-feature/ui/MyFeatureView.tsx
touch features/my-feature/README.md
```

### **3. Start with Domain**

```typescript
// features/my-feature/domain/types.ts
export interface MyFeature {
  id: string
  name: string
  createdAt: Date
}

// features/my-feature/domain/schemas.ts
import { z } from 'zod'

export const myFeatureSchema = z.object({
  id: z.string(),
  name: z.string().min(1).max(100),
  createdAt: z.date()
})
```

### **4. Add Data Layer**

```typescript
// features/my-feature/data/api.ts
export async function getMyFeature(id: string) {
  const response = await fetch(`/api/my-feature/${id}`)
  return response.json()
}

// features/my-feature/data/queries.ts
import { useQuery } from '@tanstack/react-query'
import { getMyFeature } from './api'

export function useMyFeature(id: string) {
  return useQuery({
    queryKey: ['my-feature', id],
    queryFn: () => getMyFeature(id)
  })
}
```

### **5. Build UI**

```typescript
// features/my-feature/ui/MyFeatureView.tsx
import { useMyFeature } from '../data/queries'

export function MyFeatureView({ id }: Props) {
  const { data, isLoading } = useMyFeature(id)
  
  if (isLoading) return <Loading />
  
  return (
    <Container>
      <Heading>{data.name}</Heading>
      {/* ... */}
    </Container>
  )
}
```

### **6. Add Tests**

```typescript
// tests/unit/features/my-feature/domain/types.test.ts
import { myFeatureSchema } from '@/features/my-feature/domain/schemas'

describe('MyFeature Schema', () => {
  it('validates correct data', () => {
    const valid = { id: '1', name: 'Test', createdAt: new Date() }
    expect(myFeatureSchema.parse(valid)).toEqual(valid)
  })
})
```

### **7. Document the Feature**

```markdown
// features/my-feature/README.md
# My Feature

## Purpose
[What this feature does]

## Key Files
- `domain/` - Business logic
- `ui/` - User interface
- `data/` - API integration

## Usage
[How to use this feature]
```

---

## üîó Inter-Feature Communication

### **‚úÖ Good Patterns:**

**Shared Events:**
```typescript
// Use event bus for decoupled communication
eventBus.publish('vehicle.updated', vehicleData)
```

**Shared Hooks:**
```typescript
// Export hooks from features for others to use
export { useVehicleData } from './hooks/useVehicleData'

// In other feature:
import { useVehicleData } from '@/features/vehicles/hooks/useVehicleData'
```

**Props/Composition:**
```typescript
// Compose features via props
<CaptureFlow onComplete={(data) => saveToVehicle(data)} />
```

### **‚ùå Bad Patterns:**

**Direct Imports of Internals:**
```typescript
// ‚ùå Don't import domain types directly
import { VehicleState } from '@/features/vehicles/domain/state'

// ‚úÖ Export from feature index
export { VehicleState } from './domain/state'
// Then: import { VehicleState } from '@/features/vehicles'
```

**Circular Dependencies:**
```typescript
// ‚ùå Feature A imports Feature B, Feature B imports Feature A
// ‚úÖ Extract shared code to lib/ or use events
```

---

## üéØ Feature Boundaries

### **Strong Boundaries:**

Each feature should be able to answer:
- **What does it do?** Clear purpose
- **What does it own?** Domain models, UI, data
- **What does it need?** Dependencies on other features
- **What does it expose?** Public API for other features

### **Example: Auth Feature**

```
features/auth/
‚îÇ
OWNS:
- User authentication logic
- Login/logout UI
- Auth state management
- Session handling

EXPOSES:
- useAuth() hook
- AuthProvider component
- auth utilities

DEPENDS ON:
- lib/clients/supabase
- lib/storage for tokens
```

---

## üìä Feature Health Checklist

### **Healthy Feature:**
- [ ] Has clear purpose (documented in README)
- [ ] Domain logic is pure (no side effects)
- [ ] Data layer uses React Query
- [ ] UI uses design system
- [ ] Has tests (>70% coverage)
- [ ] Has no circular dependencies
- [ ] Exports clean public API
- [ ] Types are well-defined

### **Unhealthy Feature:**
- [ ] Business logic mixed with UI
- [ ] Direct database calls from components
- [ ] No tests
- [ ] Massive files (>500 lines)
- [ ] Unclear purpose
- [ ] Tightly coupled to other features

---

## üö´ Common Mistakes

### **Don't:**

**Mix Concerns:**
```typescript
// ‚ùå UI component with business logic
export function VehicleCard({ vehicle }) {
  const total = vehicle.events.reduce(...)  // Business logic!
  const formatted = formatCurrency(total)   // Formatting!
  
  return <Card>...</Card>
}

// ‚úÖ Separate concerns
// domain/calculations.ts
export function calculateTotal(events) { ... }

// ui/VehicleCard.tsx
export function VehicleCard({ vehicle, total }) {
  return <Card>{formatCurrency(total)}</Card>
}
```

**Create God Features:**
```
‚ùå features/app/  (everything in one feature)
‚úÖ features/auth/, features/capture/, etc. (focused features)
```

**Skip Domain Layer:**
```
‚ùå Putting types in UI files
‚úÖ Dedicated domain/ folder with types
```

---

## üìö Related Documentation

- [Folder Structure Guide](../docs/architecture/FOLDER_STRUCTURE.md)
- [Naming Conventions](../docs/architecture/NAMING_CONVENTIONS.md)
- [Feature Development Guide](../docs/development/FEATURE_DEVELOPMENT.md)

---

## üí° Best Practices

1. **Start small** - Don't create all folders upfront
2. **Domain first** - Define types and business logic first
3. **Test early** - Write tests as you build
4. **Document** - Add README.md to complex features
5. **Review dependencies** - Keep features loosely coupled
6. **Extract shared code** - Don't duplicate across features

---

## ‚ùì Questions?

**"Should this be a new feature or part of existing?"**
‚Üí If it has distinct functionality ‚Üí New feature
‚Üí If it extends existing ‚Üí Add to existing

**"Where does shared code go?"**
‚Üí Used by 2+ features ‚Üí lib/
‚Üí Used by 1 feature ‚Üí features/[name]/

**"How do features communicate?"**
‚Üí Exported hooks, props, or events
‚Üí Not direct imports of internals

---

**Maintained By:** Engineering Team  
**Questions?** See [CONTRIBUTING.md](../CONTRIBUTING.md)
